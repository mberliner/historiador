name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  actions: write

env:
  APP_NAME: historiador
  LINUX_EXECUTABLE: historiador
  WINDOWS_EXECUTABLE: historiador.exe

jobs:
  trigger-ci:
    name: Trigger CI Validation
    runs-on: ubuntu-latest
    outputs:
      ci-run-id: ${{ steps.trigger.outputs.run-id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Trigger CI workflow
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            console.log('Triggering CI workflow for tag validation...');
            
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yaml',
              ref: context.ref,
              inputs: {
                triggered_by: 'release'
              }
            });
            
            console.log('CI workflow dispatch successful');
            
            // Esperar un poco para que el workflow se inicie
            await new Promise(resolve => setTimeout(resolve, 10000));
            
            // Buscar el run que acabamos de crear
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yaml',
              head_sha: context.sha,
              per_page: 5
            });
            
            console.log(`Found ${runs.data.total_count} CI runs for this commit`);
            
            if (runs.data.total_count > 0) {
              // Buscar el run mÃ¡s reciente (deberÃ­a ser el que acabamos de disparar)
              const latestRun = runs.data.workflow_runs[0];
              console.log(`Latest CI run ID: ${latestRun.id}, Status: ${latestRun.status}`);
              core.setOutput('run-id', latestRun.id);
            } else {
              core.setFailed('No CI runs found after triggering');
            }

  wait-for-ci:
    name: Wait for CI Completion
    runs-on: ubuntu-latest
    needs: trigger-ci
    
    steps:
      - name: Wait for CI to complete
        uses: actions/github-script@v7
        with:
          script: |
            const runId = ${{ needs.trigger-ci.outputs.ci-run-id }};
            console.log(`Waiting for CI run ${runId} to complete...`);
            
            let attempts = 0;
            const maxAttempts = 40; // 20 minutes max (40 * 30s)
            
            while (attempts < maxAttempts) {
              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });
              
              console.log(`Attempt ${attempts + 1}: CI Status: ${run.status}, Conclusion: ${run.conclusion}`);
              
              if (run.status === 'completed') {
                if (run.conclusion === 'success') {
                  console.log('âœ… CI completed successfully! Proceeding with release build...');
                  break;
                } else {
                  core.setFailed(`âŒ CI failed with conclusion: ${run.conclusion}. Release cancelled.`);
                  return;
                }
              }
              
              if (run.status === 'cancelled' || run.status === 'failed') {
                core.setFailed(`âŒ CI workflow ${run.status}. Release cancelled.`);
                return;
              }
              
              attempts++;
              // Esperar 30 segundos antes de verificar nuevamente
              await new Promise(resolve => setTimeout(resolve, 30000));
            }
            
            if (attempts >= maxAttempts) {
              core.setFailed('âŒ CI validation timed out after 20 minutes. Release cancelled.');
            }

  validate-latest-tag:
    name: Validate Latest Tag
    runs-on: ubuntu-latest
    needs: wait-for-ci
    outputs:
      is-latest: ${{ steps.check.outputs.is-latest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all tags
          
      - name: Check if current tag is latest
        id: check
        run: |
          echo "Current tag: ${{ github.ref_name }}"
          LATEST_TAG=$(git tag --sort=-version:refname | head -1)
          echo "Latest tag in repo: $LATEST_TAG"
          
          if [ "${{ github.ref_name }}" = "$LATEST_TAG" ]; then
            echo "âœ… Processing latest tag: ${{ github.ref_name }}"
            echo "is-latest=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Skipping: ${{ github.ref_name }} is not the latest tag ($LATEST_TAG)"
            echo "is-latest=false" >> $GITHUB_OUTPUT
          fi

  build:
    name: Build executables for multiple platforms
    runs-on: ${{ matrix.os }}
    needs: validate-latest-tag
    if: needs.validate-latest-tag.outputs.is-latest == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
          - os: windows-latest
            platform: windows

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.8
        uses: actions/setup-python@v5
        with:
          python-version: '3.8'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            %LOCALAPPDATA%\pip\Cache
          key: ${{ runner.os }}-pip-release-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-release-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Build executable with PyInstaller (Linux)
        if: matrix.platform == 'linux'
        run: |
          set -e  # Exit on any error
          pyinstaller historiador-clean.spec --clean
          # Test that executable was created
          test -f dist/${{ env.LINUX_EXECUTABLE }}

      - name: Build executable with PyInstaller (Windows)
        if: matrix.platform == 'windows'
        run: |
          pyinstaller historiador-clean.spec --clean
          # Test that executable was created (PowerShell syntax)
          if (-not (Test-Path "dist\${{ env.WINDOWS_EXECUTABLE }}")) { exit 1 }

      - name: Test executable (Linux)
        if: matrix.platform == 'linux'
        run: |
          chmod +x dist/${{ env.LINUX_EXECUTABLE }}
          ./dist/${{ env.LINUX_EXECUTABLE }} --help

      - name: Test executable (Windows)
        if: matrix.platform == 'windows'
        run: |
          .\dist\${{ env.WINDOWS_EXECUTABLE }} --help

      - name: Upload executable as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform == 'linux' && env.LINUX_EXECUTABLE || env.WINDOWS_EXECUTABLE }}
          path: dist/${{ matrix.platform == 'linux' && env.LINUX_EXECUTABLE || env.WINDOWS_EXECUTABLE }}
          retention-days: 90

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-latest-tag, build]
    if: needs.validate-latest-tag.outputs.is-latest == 'true'
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Display downloaded files
        run: |
          echo "ðŸ“¦ Downloaded artifacts:"
          ls -la artifacts/
          find artifacts/ -type f -exec ls -la {} \;

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
          generate_release_notes: true
          body: |
            ## ðŸš€ Historiador ${{ github.ref_name }}
            
            AplicaciÃ³n de lÃ­nea de comandos para importar historias de usuario desde CSV/Excel hacia Jira.
            
            ### ðŸ“¥ Descargas
            - **Linux**: ${{ env.LINUX_EXECUTABLE }}
            - **Windows**: ${{ env.WINDOWS_EXECUTABLE }}
            
            ### âœ… ValidaciÃ³n
            Este release pasÃ³ todos los quality gates:
            - PyLint score â‰¥ 8.0
            - Test coverage â‰¥ 80%
            - All unit tests passed
            
            ### ðŸ“– Uso
            ```bash
            # Linux
            chmod +x ${{ env.LINUX_EXECUTABLE }}
            ./${{ env.LINUX_EXECUTABLE }} --help
            
            # Windows
            ${{ env.WINDOWS_EXECUTABLE }} --help
            ```
          files: |
            artifacts/${{ env.LINUX_EXECUTABLE }}/${{ env.LINUX_EXECUTABLE }}
            artifacts/${{ env.WINDOWS_EXECUTABLE }}/${{ env.WINDOWS_EXECUTABLE }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}