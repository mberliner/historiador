name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  actions: write

env:
  APP_NAME: historiador
  LINUX_EXECUTABLE: historiador
  WINDOWS_EXECUTABLE: historiador.exe

jobs:
  trigger-ci:
    name: Trigger CI Validation
    runs-on: ubuntu-latest
    outputs:
      ci-run-id: ${{ steps.trigger.outputs.run-id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Trigger CI workflow
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            console.log('Triggering CI workflow for tag validation...');
            
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yaml',
              ref: context.ref,
              inputs: {
                triggered_by: 'release'
              }
            });
            
            console.log('CI workflow dispatch successful');
            
            // Esperar un poco para que el workflow se inicie
            await new Promise(resolve => setTimeout(resolve, 10000));
            
            // Buscar el run que acabamos de crear
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yaml',
              head_sha: context.sha,
              per_page: 5
            });
            
            console.log(`Found ${runs.data.total_count} CI runs for this commit`);
            
            if (runs.data.total_count > 0) {
              // Buscar el run m√°s reciente (deber√≠a ser el que acabamos de disparar)
              const latestRun = runs.data.workflow_runs[0];
              console.log(`Latest CI run ID: ${latestRun.id}, Status: ${latestRun.status}`);
              core.setOutput('run-id', latestRun.id);
            } else {
              core.setFailed('No CI runs found after triggering');
            }

  wait-for-ci:
    name: Wait for CI Completion
    runs-on: ubuntu-latest
    needs: trigger-ci
    
    steps:
      - name: Wait for CI to complete
        uses: actions/github-script@v7
        with:
          script: |
            const runId = ${{ needs.trigger-ci.outputs.ci-run-id }};
            console.log(`Waiting for CI run ${runId} to complete...`);
            
            let attempts = 0;
            const maxAttempts = 40; // 20 minutes max (40 * 30s)
            
            while (attempts < maxAttempts) {
              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });
              
              console.log(`Attempt ${attempts + 1}: CI Status: ${run.status}, Conclusion: ${run.conclusion}`);
              
              if (run.status === 'completed') {
                if (run.conclusion === 'success') {
                  console.log('‚úÖ CI completed successfully! Proceeding with release build...');
                  break;
                } else {
                  core.setFailed(`‚ùå CI failed with conclusion: ${run.conclusion}. Release cancelled.`);
                  return;
                }
              }
              
              if (run.status === 'cancelled' || run.status === 'failed') {
                core.setFailed(`‚ùå CI workflow ${run.status}. Release cancelled.`);
                return;
              }
              
              attempts++;
              // Esperar 30 segundos antes de verificar nuevamente
              await new Promise(resolve => setTimeout(resolve, 30000));
            }
            
            if (attempts >= maxAttempts) {
              core.setFailed('‚ùå CI validation timed out after 20 minutes. Release cancelled.');
            }

  build:
    name: Build executables for multiple platforms
    runs-on: ${{ matrix.os }}
    needs: wait-for-ci
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
          - os: windows-latest
            platform: windows

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.8
        uses: actions/setup-python@v5
        with:
          python-version: '3.8'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            %LOCALAPPDATA%\pip\Cache
          key: ${{ runner.os }}-pip-release-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-release-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Build executable with PyInstaller (Linux)
        if: matrix.platform == 'linux'
        run: |
          set -e  # Exit on any error
          pyinstaller historiador-clean.spec --clean
          # Test that executable was created
          test -f dist/${{ env.LINUX_EXECUTABLE }}

      - name: Build executable with PyInstaller (Windows)
        if: matrix.platform == 'windows'
        run: |
          pyinstaller historiador-clean.spec --clean
          # Test that executable was created (PowerShell syntax)
          if (-not (Test-Path "dist\${{ env.WINDOWS_EXECUTABLE }}")) { exit 1 }

      - name: Test executable (Linux)
        if: matrix.platform == 'linux'
        run: |
          chmod +x dist/${{ env.LINUX_EXECUTABLE }}
          ./dist/${{ env.LINUX_EXECUTABLE }} --help

      - name: Test executable (Windows)
        if: matrix.platform == 'windows'
        run: |
          .\dist\${{ env.WINDOWS_EXECUTABLE }} --help

      - name: Upload executable as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform == 'linux' && env.LINUX_EXECUTABLE || env.WINDOWS_EXECUTABLE }}
          path: dist/${{ matrix.platform == 'linux' && env.LINUX_EXECUTABLE || env.WINDOWS_EXECUTABLE }}
          retention-days: 90

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Display downloaded files
        run: |
          echo "üì¶ Downloaded artifacts:"
          ls -la artifacts/
          find artifacts/ -type f -exec ls -la {} \;

      - name: Validate changelog entry exists
        id: validate_changelog
        run: |
          # Obtener el tag actual
          CURRENT_TAG="${{ github.ref_name }}"
          VERSION=${CURRENT_TAG#v}

          echo "üîç Validando entrada en CHANGELOG.md para versi√≥n: $VERSION"

          # Verificar que existe la entrada en el changelog
          if ! grep -q "^## \[$VERSION\]" CHANGELOG.md; then
            echo "‚ùå ERROR: No se encontr√≥ entrada para la versi√≥n [$VERSION] en CHANGELOG.md"
            echo ""
            echo "üìã Acciones requeridas:"
            echo "1. Agregar secci√≥n para la versi√≥n $VERSION en CHANGELOG.md"
            echo "2. Seguir el formato: ## [$VERSION] - $(date +%Y-%m-%d)"
            echo "3. Incluir categor√≠as apropiadas (üéâ Added, üîß Changed, üêõ Fixed, etc.)"
            echo ""
            echo "üìñ Ejemplo:"
            echo "## [$VERSION] - $(date +%Y-%m-%d)"
            echo ""
            echo "### üéâ Added"
            echo "- Nueva funcionalidad..."
            echo ""
            echo "### üêõ Fixed"
            echo "- Correcci√≥n de..."
            echo ""
            echo "Ver CHANGELOG.md para m√°s ejemplos de formato."
            echo ""
            echo "üí° Tip: Aseg√∫rate de que el tag $CURRENT_TAG corresponde a los cambios documentados"
            exit 1
          fi

          # Verificar que hay contenido en la secci√≥n (no est√° vac√≠a)
          CHANGELOG_CONTENT=$(awk "/^## \[$VERSION\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md | sed '/^$/d')

          if [ -z "$CHANGELOG_CONTENT" ]; then
            echo "‚ùå ERROR: La secci√≥n [$VERSION] en CHANGELOG.md est√° vac√≠a"
            echo ""
            echo "üìã Acci√≥n requerida:"
            echo "- Agregar contenido descriptivo de los cambios en la versi√≥n $VERSION"
            echo "- Usar categor√≠as apropiadas (üéâ Added, üîß Changed, üêõ Fixed, etc.)"
            echo ""
            echo "El release no puede continuar con una secci√≥n vac√≠a."
            exit 1
          fi

          echo "‚úÖ Validaci√≥n exitosa: Entrada encontrada para versi√≥n [$VERSION]"
          echo "üìù Contenido del changelog validado correctamente"

      - name: Extract changelog for release
        id: changelog
        run: |
          # Obtener el tag actual (ya validado en el paso anterior)
          CURRENT_TAG="${{ github.ref_name }}"
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT

          # Obtener tag anterior
          PREVIOUS_TAG=$(git tag --sort=-version:refname | head -2 | tail -1 || echo "")
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

          # Extraer contenido del changelog para la versi√≥n actual
          VERSION=${CURRENT_TAG#v}

          # Buscar contenido de la versi√≥n actual en CHANGELOG.md (ya validado que existe)
          CHANGELOG_CONTENT=$(awk "/^## \[$VERSION\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md | sed '/^$/d')

          # Guardar en archivo temporal para el release
          cat > changelog_content.txt << 'EOF'
          $CHANGELOG_CONTENT
          EOF

          # Expandir variables en el contenido
          eval "cat > changelog_final.txt << 'EOL'
          $(cat changelog_content.txt)
          EOL"

          echo "üìä Estad√≠sticas del changelog:"
          echo "- L√≠neas de cambios: $(echo "$CHANGELOG_CONTENT" | wc -l)"
          echo "- Categor√≠as detectadas: $(echo "$CHANGELOG_CONTENT" | grep -c "^###" || echo "0")"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: 'Historiador ${{ github.ref_name }}'
          draft: false
          prerelease: false
          generate_release_notes: false
          body: |
            ## üì¶ Historiador ${{ github.ref_name }}

            Ejecutable CLI optimizado para importar historias de usuario desde CSV/Excel a Jira.

            ### üöÄ Cambios en esta versi√≥n

            $(cat changelog_final.txt)

            ### üì• Descargas
            - **Linux x64**: `${{ env.LINUX_EXECUTABLE }}` (~51MB optimizado)
            - **Windows x64**: `${{ env.WINDOWS_EXECUTABLE }}` (~53MB optimizado)

            ### ‚úÖ Quality Gates Validados
            - **PyLint Score**: ‚â•8.0 (c√≥digo de calidad)
            - **Test Coverage**: ‚â•80% (cobertura de tests)
            - **Unit Tests**: Todos los tests pasando (366+ tests)
            - **Build**: Ejecutables generados y validados

            ### üìã Informaci√≥n del Build
            - **Tag**: `${{ github.ref_name }}`
            - **Commit**: `${{ github.sha }}`
            - **Workflow**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - **Arquitectura**: Clean Architecture (4 capas)
            - **Compatibilidad**: Python 3.8+ / Linux x64 / Windows x64

            ### üîß Uso R√°pido
            ```bash
            # Linux
            chmod +x ${{ env.LINUX_EXECUTABLE }}
            ./${{ env.LINUX_EXECUTABLE }} --help
            ./${{ env.LINUX_EXECUTABLE }} -p TU_PROYECTO --dry-run

            # Windows
            ${{ env.WINDOWS_EXECUTABLE }} --help
            ${{ env.WINDOWS_EXECUTABLE }} -p TU_PROYECTO --dry-run
            ```

            ### üìö Documentaci√≥n
            - [README.md](README.md): Gu√≠a de inicio r√°pido
            - [DOCS.md](DOCS.md): Documentaci√≥n completa del proyecto
            - [CHANGELOG.md](CHANGELOG.md): Historial completo de cambios
          files: |
            artifacts/${{ env.LINUX_EXECUTABLE }}/${{ env.LINUX_EXECUTABLE }}
            artifacts/${{ env.WINDOWS_EXECUTABLE }}/${{ env.WINDOWS_EXECUTABLE }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}